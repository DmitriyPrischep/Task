# Постановка задачи

Процессу на stdin приходят строки, содержащие URL или названия файлов. Каждый такой URL нужно запросить, каждый файл нужно прочитать, и посчитать кол-во вхождений строки "Go" в ответе. В конце работы приложение выводит на экран общее кол-во найденных строк "Go" во всех источниках данных, например:

$ echo -e  'https://golang.org\n/etc/passwd\nhttps://golang.org\nhttps://golan g.org' | go run 1.go 

Count for https://golang.org: 9 <br>
Count for /etc/passwd: 0 <br>
Count for https://golang.org: 9 <br>
Count for https://golang.org: 9 <br>
Total: 27 

Каждый источник данных должен начать обрабатываться сразу после вычитывания и параллельно с вычитыванием следующего. Источники должны обрабатываться параллельно,но не более k=5 одновременно. Обработчики данных не должны порождать лишних горутин, т.е. если k=1000 а обрабатываемых источников нет, не должно создаваться 1000 горутин. Нужно обойтись без глобальных переменных и использовать только стандартные библиотеки

# Решение
Решение создаются 5 воркеров, которые слушают канал, в который записываются задания (имя файла или URL, в которых далее параллельно считается вхождение подстроки в тексте). И параллельно суммируются результаты количеств вхождений

Для управления выполнением задания был использован контекс. Задания можно отменить во время выполнения, если содержимое файла или тело ответа на запрос оказалось очень большим.

Для проверки работоспособности программы были написаны тесты. Для возможности взаимодействия тестов с файловой системой и сетью, они были спрятаны за интерфейс, что позволило отвязаться от реальных файлов и сетевых запросов.

Минусом решения задачи является невозможность поиска паттерна с переносом строки